---
ms.date: 02/03/2020
keywords: powershell, 核心
title: PowerShell 6.0 的已知问题
description: 这是对 PowerShell 6 中的已知问题或限制的总结
ms.openlocfilehash: 528315eff660167513045542227dce335355a7b8
ms.sourcegitcommit: 9080316e3ca4f11d83067b41351531672b667b7a
ms.translationtype: HT
ms.contentlocale: zh-CN
ms.lasthandoff: 10/24/2020
ms.locfileid: "92501671"
---
# <a name="known-issues-for-powershell-60"></a><span data-ttu-id="c14d5-104">PowerShell 6.0 的已知问题</span><span class="sxs-lookup"><span data-stu-id="c14d5-104">Known Issues for PowerShell 6.0</span></span>

## <a name="known-issues-for-powershell-on-non-windows-platforms"></a><span data-ttu-id="c14d5-105">非 Windows 平台上 PowerShell 的已知问题</span><span class="sxs-lookup"><span data-stu-id="c14d5-105">Known Issues for PowerShell on Non-Windows Platforms</span></span>

<span data-ttu-id="c14d5-106">Linux 和 macOS 上的 PowerShell 的 Alpha 版本通常能正常运行，但确实存在一些明显的限制和可用性问题。</span><span class="sxs-lookup"><span data-stu-id="c14d5-106">Alpha releases of PowerShell on Linux and macOS are mostly functional but do have some significant limitations and usability issues.</span></span> <span data-ttu-id="c14d5-107">Linux 和 macOS 上的 PowerShell 的 Beta 版本比 alpha 版本功能更加强大且稳定，但仍可能缺少一些功能，并可能包含 bug。</span><span class="sxs-lookup"><span data-stu-id="c14d5-107">Beta releases of PowerShell on Linux and macOS are more functional and stable than alpha releases, but still may be lacking some set of features, and can contain bugs.</span></span> <span data-ttu-id="c14d5-108">在某些情况下，这些问题只是尚未得到修复的 bug。</span><span class="sxs-lookup"><span data-stu-id="c14d5-108">In some cases, these issues are simply bugs that haven't been fixed yet.</span></span> <span data-ttu-id="c14d5-109">在其他情况下（对于 ls、cp 等的默认别名），我们正在寻求社区对我们所做选择的反馈。</span><span class="sxs-lookup"><span data-stu-id="c14d5-109">In other cases (as with the default aliases for ls, cp, etc.), we are looking for feedback from the community regarding the choices we make.</span></span>

<span data-ttu-id="c14d5-110">注意：由于许多基础子系统的相似性，Linux 和 macOS 上的 PowerShell 倾向于在功能和 bug 方面共享相同的成熟度级别。</span><span class="sxs-lookup"><span data-stu-id="c14d5-110">Note: Due to the similarities of many underlying subsystems, PowerShell on Linux and macOS tend to share the same level of maturity in both features and bugs.</span></span> <span data-ttu-id="c14d5-111">除下文所述，本部分中的问题适用于这两个操作系统。</span><span class="sxs-lookup"><span data-stu-id="c14d5-111">Except as noted below, the issues in this section apply to both operating systems.</span></span>

### <a name="case-sensitivity-in-powershell"></a><span data-ttu-id="c14d5-112">PowerShell 中的区分大小写</span><span class="sxs-lookup"><span data-stu-id="c14d5-112">Case-sensitivity in PowerShell</span></span>

<span data-ttu-id="c14d5-113">PowerShell 一直以来均区分大小写，只有少数例外情况。</span><span class="sxs-lookup"><span data-stu-id="c14d5-113">Historically, PowerShell has been uniformly case-insensitive, with few exceptions.</span></span> <span data-ttu-id="c14d5-114">在类似于 UNIX 的操作系统上，文件系统基本都区分大小写，并且 PowerShell 遵守文件系统的标准；这通过多种方式显示，明显和非明显的方式。</span><span class="sxs-lookup"><span data-stu-id="c14d5-114">On UNIX-like operating systems, the file system is predominantly case-sensitive and PowerShell adheres to the standard of the file system; this is exposed through a number of ways, obvious and non-obvious.</span></span>

#### <a name="directly"></a><span data-ttu-id="c14d5-115">直接</span><span class="sxs-lookup"><span data-stu-id="c14d5-115">Directly</span></span>

- <span data-ttu-id="c14d5-116">在 PowerShell 中指定一个文件时，必须使用正确的大小写。</span><span class="sxs-lookup"><span data-stu-id="c14d5-116">When specifying a file in PowerShell, the correct case must be used.</span></span>

#### <a name="indirectly"></a><span data-ttu-id="c14d5-117">间接</span><span class="sxs-lookup"><span data-stu-id="c14d5-117">Indirectly</span></span>

- <span data-ttu-id="c14d5-118">如果脚本尝试加载模块，而模块名称的大小写不正确，则模块加载失败。</span><span class="sxs-lookup"><span data-stu-id="c14d5-118">If a script tries to load a module and the module name is not cased correctly, then the module load fails.</span></span> <span data-ttu-id="c14d5-119">如果引用模块所依据的名称与实际文件名不一致，这可能会导致现有脚本出现问题。</span><span class="sxs-lookup"><span data-stu-id="c14d5-119">This may cause a problem with existing scripts if the name by which the module is referenced doesn't match the actual filename.</span></span>
- <span data-ttu-id="c14d5-120">如果文件名的大小写不正确，Tab 键补全不会自动完成。</span><span class="sxs-lookup"><span data-stu-id="c14d5-120">Tab-completion does not auto-complete if the filename case is wrong.</span></span> <span data-ttu-id="c14d5-121">要完成的片段必须采用正确的大小写。</span><span class="sxs-lookup"><span data-stu-id="c14d5-121">The fragment to complete must be cased properly.</span></span> <span data-ttu-id="c14d5-122">（对于类型名称和类型成员完成，完成是不区分大小写的。）</span><span class="sxs-lookup"><span data-stu-id="c14d5-122">(Completion is case-insensitive for type name and type member completions.)</span></span>

### <a name="ps1-file-extensions"></a><span data-ttu-id="c14d5-123">.PS1 文件扩展名</span><span class="sxs-lookup"><span data-stu-id="c14d5-123">.PS1 File Extensions</span></span>

<span data-ttu-id="c14d5-124">PowerShell 脚本必须以 `.ps1` 结尾，以便解释器了解如何在当前进程中加载并运行它们。</span><span class="sxs-lookup"><span data-stu-id="c14d5-124">PowerShell scripts must end in `.ps1` for the interpreter to understand how to load and run them in the current process.</span></span> <span data-ttu-id="c14d5-125">在当前进程中运行脚本是 PowerShell 的预期常见行为。</span><span class="sxs-lookup"><span data-stu-id="c14d5-125">Running scripts in the current process is the expected usual behavior for PowerShell.</span></span> <span data-ttu-id="c14d5-126">可以将 `#!` 幻数添加到没有 `.ps1` 扩展名的脚本中，但这会导致脚本在新的 PowerShell 实例中运行，进而导致脚本无法在交换对象时正常运行。</span><span class="sxs-lookup"><span data-stu-id="c14d5-126">The `#!` magic number may be added to a script that doesn't have a `.ps1` extension, but this causes the script to be run in a new PowerShell instance preventing the script from working properly when interchanging objects.</span></span> <span data-ttu-id="c14d5-127">（注意：这可能是从 `bash` 或其他 shell 执行 PowerShell 脚本时所期望的行为。）</span><span class="sxs-lookup"><span data-stu-id="c14d5-127">(Note: this may be the desirable behavior when executing a PowerShell script from `bash` or another shell.)</span></span>

### <a name="missing-command-aliases"></a><span data-ttu-id="c14d5-128">缺少命令别名</span><span class="sxs-lookup"><span data-stu-id="c14d5-128">Missing command aliases</span></span>

<span data-ttu-id="c14d5-129">在 Linux/macOS 上，已删除基本命令 `ls`、`cp`、`mv`、`rm`、`cat`、`man`、`mount`、`ps` 的“方便别名”。</span><span class="sxs-lookup"><span data-stu-id="c14d5-129">On Linux/macOS, the "convenience aliases" for the basic commands `ls`, `cp`, `mv`, `rm`, `cat`, `man`, `mount`, `ps` have been removed.</span></span> <span data-ttu-id="c14d5-130">在 Windows 上，为了方便用户，PowerShell 提供一组映射到 Linux 命令名的别名。</span><span class="sxs-lookup"><span data-stu-id="c14d5-130">On Windows, PowerShell provides a set of aliases that map to Linux command names for user convenience.</span></span> <span data-ttu-id="c14d5-131">已从 Linux/macOS 分发上的默认 PowerShell 中删除这些别名，以允许在不指定路径的情况下运行本机可执行文件。</span><span class="sxs-lookup"><span data-stu-id="c14d5-131">These aliases have been removed from the default PowerShell on Linux/macOS distributions, allowing the native executable to be run without specifying a path.</span></span>

<span data-ttu-id="c14d5-132">执行此操作既有优点，又有缺点。</span><span class="sxs-lookup"><span data-stu-id="c14d5-132">There are pros and cons to doing this.</span></span> <span data-ttu-id="c14d5-133">删除别名会向 PowerShell 用户公开本机命令体验，但会降低 shell 中的功能，因为本机命令会返回字符串，而不是对象。</span><span class="sxs-lookup"><span data-stu-id="c14d5-133">Removing the aliases exposes the native command experience to the PowerShell user, but reduces functionality in the shell because the native commands return strings instead of objects.</span></span>

> [!NOTE]
> <span data-ttu-id="c14d5-134">PowerShell 团队正在寻求此方面的反馈。</span><span class="sxs-lookup"><span data-stu-id="c14d5-134">This is an area where the PowerShell team is looking for feedback.</span></span> <span data-ttu-id="c14d5-135">首选解决方案是什么？</span><span class="sxs-lookup"><span data-stu-id="c14d5-135">What is the preferred solution?</span></span>
> <span data-ttu-id="c14d5-136">我们应保持原样还是重新添加方便别名？</span><span class="sxs-lookup"><span data-stu-id="c14d5-136">Should we leave it as is or add the convenience aliases back?</span></span> <span data-ttu-id="c14d5-137">请参阅[问题 #929](https://github.com/PowerShell/PowerShell/issues/929)。</span><span class="sxs-lookup"><span data-stu-id="c14d5-137">See [Issue #929](https://github.com/PowerShell/PowerShell/issues/929).</span></span>

### <a name="missing-wildcard-globbing-support"></a><span data-ttu-id="c14d5-138">缺少通配符（通配）支持</span><span class="sxs-lookup"><span data-stu-id="c14d5-138">Missing Wildcard (globbing) Support</span></span>

<span data-ttu-id="c14d5-139">目前，PowerShell 只对 Windows 上的内置 cmdlet 和 Linux 上的外部命令或二进制文件及 cmdlet 做通配符扩展（通配）。</span><span class="sxs-lookup"><span data-stu-id="c14d5-139">Currently, PowerShell only does wildcard expansion (globbing) for built-in cmdlets on Windows, and for external commands or binaries as well as cmdlets on Linux.</span></span> <span data-ttu-id="c14d5-140">也就是说，诸如 `ls
*.txt` 之类的命令会失败，因为星号不会展开来匹配文件名。</span><span class="sxs-lookup"><span data-stu-id="c14d5-140">This means that a command like `ls
*.txt` fails because the asterisk is not expanded to match filenames.</span></span> <span data-ttu-id="c14d5-141">可以通过执行 `ls (gci *.txt | % name)` ，或更简单地使用等效于 `ls` 的 PowerShell 内置项来执行 `gci *.txt` 以解决此问题。</span><span class="sxs-lookup"><span data-stu-id="c14d5-141">You can work around this by doing `ls (gci *.txt | % name)` or, more simply, `gci *.txt` using the PowerShell built-in equivalent to `ls`.</span></span>

<span data-ttu-id="c14d5-142">请参阅 [#954](https://github.com/PowerShell/PowerShell/issues/954) 提供有关如何改进 Linux/macOS 上通配体验的反馈。</span><span class="sxs-lookup"><span data-stu-id="c14d5-142">See [#954](https://github.com/PowerShell/PowerShell/issues/954) to give us feedback on how to improve the globbing experience on Linux/macOS.</span></span>

### <a name="net-framework-vs-net-core-framework"></a><span data-ttu-id="c14d5-143">.NET Framework 和 .NET Core Framework</span><span class="sxs-lookup"><span data-stu-id="c14d5-143">.NET Framework vs .NET Core Framework</span></span>

<span data-ttu-id="c14d5-144">Linux/macOS 上的 PowerShell 使用 .NET Core，即 Microsoft Windows 上的完整 .NET Framework 的子集。</span><span class="sxs-lookup"><span data-stu-id="c14d5-144">PowerShell on Linux/macOS uses .NET Core which is a subset of the full .NET Framework on Microsoft Windows.</span></span> <span data-ttu-id="c14d5-145">这非常重要，因为 PowerShell 提供对基础框架类型、方法等的直接访问。因此，在 Windows 上运行的脚本可能无法在非 Windows 平台上运行，因为框架之间存在差异。</span><span class="sxs-lookup"><span data-stu-id="c14d5-145">This is significant because PowerShell provides direct access to the underlying framework types, methods, etc. As a result, scripts that run on Windows may not run on non-Windows platforms because of the differences in the frameworks.</span></span> <span data-ttu-id="c14d5-146">有关 .NET Core Framework 的详细信息，请参阅 [dotnetfoundation.org](https://dotnetfoundation.org/)。</span><span class="sxs-lookup"><span data-stu-id="c14d5-146">For more information about .NET Core Framework, see [dotnetfoundation.org](https://dotnetfoundation.org/).</span></span>

<span data-ttu-id="c14d5-147">随着 [.NET Standard 2.0](https://devblogs.microsoft.com/dotnet/introducing-net-standard/) 推出，.NET Core 2.0 恢复了完整 .NET Framework 中的许多传统类型和方法。</span><span class="sxs-lookup"><span data-stu-id="c14d5-147">With the advent of [.NET Standard 2.0](https://devblogs.microsoft.com/dotnet/introducing-net-standard/), .NET Core 2.0 brings back many of the traditional types and methods present in the full .NET Framework.</span></span> <span data-ttu-id="c14d5-148">也就是说，PowerShell Core 能够加载许多传统 Windows PowerShell 模块，而无需修改。</span><span class="sxs-lookup"><span data-stu-id="c14d5-148">This means that PowerShell Core can load many traditional Windows PowerShell modules without modification.</span></span> <span data-ttu-id="c14d5-149">可以在[此处](https://github.com/PowerShell/PowerShell/projects/4)了解我们有关 .NET Standard 2.0 的工作。</span><span class="sxs-lookup"><span data-stu-id="c14d5-149">You can follow our .NET Standard 2.0 related work [here](https://github.com/PowerShell/PowerShell/projects/4).</span></span>

### <a name="redirection-issues"></a><span data-ttu-id="c14d5-150">重定向问题</span><span class="sxs-lookup"><span data-stu-id="c14d5-150">Redirection Issues</span></span>

<span data-ttu-id="c14d5-151">任何平台上的 PowerShell 中均不支持输入重定向。</span><span class="sxs-lookup"><span data-stu-id="c14d5-151">Input redirection is not supported in PowerShell on any platform.</span></span>
[<span data-ttu-id="c14d5-152">问题 #1629</span><span class="sxs-lookup"><span data-stu-id="c14d5-152">Issue #1629</span></span>](https://github.com/PowerShell/PowerShell/issues/1629)

<span data-ttu-id="c14d5-153">使用 `Get-Content` 将文件内容写入管道。</span><span class="sxs-lookup"><span data-stu-id="c14d5-153">Use `Get-Content` to write the contents of a file into the pipeline.</span></span>

<span data-ttu-id="c14d5-154">如果使用的是默认 UTF-8 编码，重定向的输出包含 Unicode 字节顺序标记 (BOM)。</span><span class="sxs-lookup"><span data-stu-id="c14d5-154">Redirected output contains the Unicode byte order mark (BOM) when the default UTF-8 encoding is used.</span></span> <span data-ttu-id="c14d5-155">在与不应出现的实用工具配合使用或附加到文件时，BOM 会导致问题出现。</span><span class="sxs-lookup"><span data-stu-id="c14d5-155">The BOM causes problems when working with utilities that do not expect it or when appending to a file.</span></span> <span data-ttu-id="c14d5-156">使用 `-Encoding Ascii` 编写不包含 BOM 的 ASCII 文本。</span><span class="sxs-lookup"><span data-stu-id="c14d5-156">Use `-Encoding Ascii` to write ASCII text, which does not have a BOM.</span></span>

> [!Note]
> <span data-ttu-id="c14d5-157">请参阅 [RFC0020](https://github.com/PowerShell/PowerShell-RFC/issues/71)，向我们提供有关在所有平台上改进 PowerShell Core 编码体验的反馈。</span><span class="sxs-lookup"><span data-stu-id="c14d5-157">see [RFC0020](https://github.com/PowerShell/PowerShell-RFC/issues/71) to give us feedback on improving the encoding experience for PowerShell Core across all platforms.</span></span> <span data-ttu-id="c14d5-158">我们致力于支持不带 BOM 的 UTF-8，以及可能不断变化的各种跨平台的 cmdlet 的编码默认值。</span><span class="sxs-lookup"><span data-stu-id="c14d5-158">We are working to support UTF-8 without a BOM and potentially changing the encoding defaults for various cmdlets across platforms.</span></span>

### <a name="job-control"></a><span data-ttu-id="c14d5-159">作业控制</span><span class="sxs-lookup"><span data-stu-id="c14d5-159">Job Control</span></span>

<span data-ttu-id="c14d5-160">Linux/macOS 上的 PowerShell 中不支持作业控制。</span><span class="sxs-lookup"><span data-stu-id="c14d5-160">There is no job-control support in PowerShell on Linux/macOS.</span></span>
<span data-ttu-id="c14d5-161">`fg` 和 `bg` 命令不可用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-161">The `fg` and `bg` commands are not available.</span></span>

<span data-ttu-id="c14d5-162">目前，可以使用跨所有平台执行操作的 [PowerShell 作业](/powershell/module/microsoft.powershell.core/about/about_jobs)。</span><span class="sxs-lookup"><span data-stu-id="c14d5-162">For the time being, you can use [PowerShell jobs](/powershell/module/microsoft.powershell.core/about/about_jobs) which do work across all platforms.</span></span>

### <a name="remoting-support"></a><span data-ttu-id="c14d5-163">远程处理支持</span><span class="sxs-lookup"><span data-stu-id="c14d5-163">Remoting Support</span></span>

<span data-ttu-id="c14d5-164">目前，PowerShell Core 支持在 macOS 和 Linux 上经过基本身份验证以及在 Linux 上经过基于 NTLM 的身份验证的通过 WSMan 的 PowerShell 远程处理 (PSRP)。</span><span class="sxs-lookup"><span data-stu-id="c14d5-164">Currently, PowerShell Core supports PowerShell Remoting (PSRP) over WSMan with Basic authentication on macOS and Linux, and with NTLM-based authentication on Linux.</span></span> <span data-ttu-id="c14d5-165">（不支持基于 Kerberos 的身份验证。）</span><span class="sxs-lookup"><span data-stu-id="c14d5-165">(Kerberos-based authentication is not supported.)</span></span>

<span data-ttu-id="c14d5-166">在 [psl-omi-provider](https://github.com/PowerShell/psl-omi-provider) 存储库中完成基于 WSMan 的远程处理工作。</span><span class="sxs-lookup"><span data-stu-id="c14d5-166">The work for WSMan-based remoting is being done in the [psl-omi-provider](https://github.com/PowerShell/psl-omi-provider) repo.</span></span>

<span data-ttu-id="c14d5-167">PowerShell Core 还支持所有平台（Windows、macOS 和 Linux）上通过 SSH 的 PowerShell 远程处理 (PSRP)。</span><span class="sxs-lookup"><span data-stu-id="c14d5-167">PowerShell Core also supports PowerShell Remoting (PSRP) over SSH on all platforms (Windows, macOS, and Linux).</span></span> <span data-ttu-id="c14d5-168">虽然目前在生产中不支持此功能，但可以在[此处](../learn/remoting/SSH-Remoting-in-PowerShell-Core.md)了解有关此设置的详细信息。</span><span class="sxs-lookup"><span data-stu-id="c14d5-168">While this is not currently supported in production, you can learn more about setting this up [here](../learn/remoting/SSH-Remoting-in-PowerShell-Core.md).</span></span>

### <a name="just-enough-administration-jea-support"></a><span data-ttu-id="c14d5-169">Just-Enough-Administration (JEA) 支持</span><span class="sxs-lookup"><span data-stu-id="c14d5-169">Just-Enough-Administration (JEA) Support</span></span>

<span data-ttu-id="c14d5-170">Linux/macOS 上的 PowerShell 目前无法创建约束管理 (JEA) 远程处理终结点。</span><span class="sxs-lookup"><span data-stu-id="c14d5-170">The ability to create constrained administration (JEA) remoting endpoints is not currently available in PowerShell on Linux/macOS.</span></span> <span data-ttu-id="c14d5-171">此功能目前不在 6.0 的范围内，我们将在后 6.0 中考虑此功能，因为它需要大量的设计工作。</span><span class="sxs-lookup"><span data-stu-id="c14d5-171">This feature is currently not in scope for 6.0 and something we will consider post 6.0 as it requires significant design work.</span></span>

### <a name="sudo-exec-and-powershell"></a><span data-ttu-id="c14d5-172">`sudo`、`exec` 和 PowerShell</span><span class="sxs-lookup"><span data-stu-id="c14d5-172">`sudo`, `exec`, and PowerShell</span></span>

<span data-ttu-id="c14d5-173">由于 PowerShell 在内存（如 Python 或 Ruby）中运行大多数命令，不能直接将 sudo 与 PowerShell 内置项一起使用。（当然，可以从 sudo 运行 `pwsh`。）如果需要使用 sudo（例如，`sudo Set-Date 8/18/2016`）从 PowerShell 内运行 PowerShell cmdlet，则要执行 `sudo pwsh Set-Date 8/18/2016`。</span><span class="sxs-lookup"><span data-stu-id="c14d5-173">Because PowerShell runs most commands in memory (like Python or Ruby), you can't use sudo directly with PowerShell built-ins. (You can, of course, run `pwsh` from sudo.) If it is necessary to run a PowerShell cmdlet from within PowerShell with sudo, for example, `sudo Set-Date 8/18/2016`, then you would do `sudo pwsh Set-Date 8/18/2016`.</span></span> <span data-ttu-id="c14d5-174">同样，不能直接执行 PowerShell 内置项。</span><span class="sxs-lookup"><span data-stu-id="c14d5-174">Likewise, you can't exec a PowerShell built-in directly.</span></span> <span data-ttu-id="c14d5-175">而必须执行 `exec pwsh item_to_exec`。</span><span class="sxs-lookup"><span data-stu-id="c14d5-175">Instead you would have to do `exec pwsh item_to_exec`.</span></span>

<span data-ttu-id="c14d5-176">此问题正作为 [#3232](https://github.com/PowerShell/PowerShell/issues/3232) 的一部分进行跟踪。</span><span class="sxs-lookup"><span data-stu-id="c14d5-176">This issue is being tracked as part of [#3232](https://github.com/PowerShell/PowerShell/issues/3232).</span></span>

### <a name="missing-cmdlets"></a><span data-ttu-id="c14d5-177">缺少 Cmdlet</span><span class="sxs-lookup"><span data-stu-id="c14d5-177">Missing Cmdlets</span></span>

<span data-ttu-id="c14d5-178">通常可用于 PowerShell 的大多数命令 (cmdlet) 在 Linux/macOS 上不可用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-178">A large number of the commands (cmdlets) normally available in PowerShell are not available on Linux/macOS.</span></span> <span data-ttu-id="c14d5-179">在许多情况下，这些命令在这些平台（例如，类似于注册表的 Windows 特定的功能）上没有意义。</span><span class="sxs-lookup"><span data-stu-id="c14d5-179">In many cases, these commands make no sense on these platforms (e.g. Windows-specific features like the registry).</span></span> <span data-ttu-id="c14d5-180">类似于服务控制命令 (Get/Start/Stop-Service) 的其他命令存在，但不起作用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-180">Other commands like the service control commands (Get/Start/Stop-Service) are present, but not functional.</span></span> <span data-ttu-id="c14d5-181">将来发布的版本可能会纠正这些问题，具体方法是修复损坏的 cmdlet，并随时间推移添加新 cmdlet。</span><span class="sxs-lookup"><span data-stu-id="c14d5-181">Future releases may correct these problems by fixing the broken cmdlets and adding new ones over time.</span></span>

### <a name="command-availability"></a><span data-ttu-id="c14d5-182">命令可用性</span><span class="sxs-lookup"><span data-stu-id="c14d5-182">Command Availability</span></span>

<span data-ttu-id="c14d5-183">下表列出了 Linux/macOS 上的 PowerShell 中已知不起作用的命令。</span><span class="sxs-lookup"><span data-stu-id="c14d5-183">The following table lists commands that are known not to work in PowerShell on Linux/macOS.</span></span>

|<span data-ttu-id="c14d5-184">命令</span><span class="sxs-lookup"><span data-stu-id="c14d5-184">Commands</span></span>|<span data-ttu-id="c14d5-185">操作状态</span><span class="sxs-lookup"><span data-stu-id="c14d5-185">Operational State</span></span>|<span data-ttu-id="c14d5-186">说明</span><span class="sxs-lookup"><span data-stu-id="c14d5-186">Notes</span></span>|
|--------|-----------------|-----|
|<span data-ttu-id="c14d5-187">`Get-Service`, `New-Service`, `Restart-Service`, `Resume-Service`, `Set-Service`, `Start-Service`, `Stop-Service`, `Suspend-Service`</span><span class="sxs-lookup"><span data-stu-id="c14d5-187">`Get-Service`, `New-Service`, `Restart-Service`, `Resume-Service`, `Set-Service`, `Start-Service`, `Stop-Service`, `Suspend-Service`</span></span>|<span data-ttu-id="c14d5-188">不可用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-188">Not Available.</span></span>|<span data-ttu-id="c14d5-189">这些命令无法识别。</span><span class="sxs-lookup"><span data-stu-id="c14d5-189">These commands are not recognized.</span></span> <span data-ttu-id="c14d5-190">应在将来的版本中解决此问题。</span><span class="sxs-lookup"><span data-stu-id="c14d5-190">This should be fixed in a future release.</span></span>|
|<span data-ttu-id="c14d5-191">`Get-Acl`, `Get-AuthenticodeSignature`, `Get-CmsMessage`, `New-FileCatalog`, `Protect-CmsMessage`, `Set-Acl`, `Set-AuthenticodeSignature`, `Test-FileCatalog`, `Unprotect-CmsMessage`</span><span class="sxs-lookup"><span data-stu-id="c14d5-191">`Get-Acl`, `Get-AuthenticodeSignature`, `Get-CmsMessage`, `New-FileCatalog`, `Protect-CmsMessage`, `Set-Acl`, `Set-AuthenticodeSignature`, `Test-FileCatalog`, `Unprotect-CmsMessage`</span></span>|<span data-ttu-id="c14d5-192">不可用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-192">Not available.</span></span>|<span data-ttu-id="c14d5-193">这些命令无法识别。</span><span class="sxs-lookup"><span data-stu-id="c14d5-193">These commands are not recognized.</span></span> <span data-ttu-id="c14d5-194">应在将来的版本中解决此问题。</span><span class="sxs-lookup"><span data-stu-id="c14d5-194">This should be fixed in a future release.</span></span>|
|`Wait-Process`|<span data-ttu-id="c14d5-195">可用，无法正常工作。</span><span class="sxs-lookup"><span data-stu-id="c14d5-195">Available, doesn't work properly.</span></span> |<span data-ttu-id="c14d5-196">例如，`Start-Process gvim -PassThru | Wait-Process` 无效；它无法等待进程。</span><span class="sxs-lookup"><span data-stu-id="c14d5-196">For example `Start-Process gvim -PassThru | Wait-Process` doesn't work; it fails to wait for the process.</span></span>|
|<span data-ttu-id="c14d5-197">`Connect-PSSession`, `Disable-PSRemoting`, `Disable-PSSessionConfiguration`, `Disconnect-PSSession`, `Enable-PSRemoting`, `Enable-PSSessionConfiguration`, `Get-PSSessionCapability`, `Get-PSSessionConfiguration`, `New-PSSessionConfigurationFile`, `Receive-PSSession`, `Register-PSSessionConfiguration`, `Set-PSSessionConfiguration`, `Test-PSSessionConfigurationFile`, `Unregister-PSSessionConfiguration`</span><span class="sxs-lookup"><span data-stu-id="c14d5-197">`Connect-PSSession`, `Disable-PSRemoting`, `Disable-PSSessionConfiguration`, `Disconnect-PSSession`, `Enable-PSRemoting`, `Enable-PSSessionConfiguration`, `Get-PSSessionCapability`, `Get-PSSessionConfiguration`, `New-PSSessionConfigurationFile`, `Receive-PSSession`, `Register-PSSessionConfiguration`, `Set-PSSessionConfiguration`, `Test-PSSessionConfigurationFile`, `Unregister-PSSessionConfiguration`</span></span>|<span data-ttu-id="c14d5-198">不可用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-198">Not Available.</span></span>|<span data-ttu-id="c14d5-199">这些命令无法识别。</span><span class="sxs-lookup"><span data-stu-id="c14d5-199">These commands are not recognized.</span></span> <span data-ttu-id="c14d5-200">应在将来的版本中解决此问题。</span><span class="sxs-lookup"><span data-stu-id="c14d5-200">This should be fixed in a future release.</span></span>|
|<span data-ttu-id="c14d5-201">`Get-Event`, `New-Event`, `Register-EngineEvent`, `Remove-Event`, `Unregister-Event`</span><span class="sxs-lookup"><span data-stu-id="c14d5-201">`Get-Event`, `New-Event`, `Register-EngineEvent`, `Remove-Event`, `Unregister-Event`</span></span>|<span data-ttu-id="c14d5-202">可用，但没有可用的事件源。</span><span class="sxs-lookup"><span data-stu-id="c14d5-202">Available but no event sources are available.</span></span>|<span data-ttu-id="c14d5-203">PowerShell 事件命令存在，但与命令一起使用的大部分事件源（例如 System.Timers.Timer）在 Linux 上不可用，使得 Alpha 版本中的命令无效。</span><span class="sxs-lookup"><span data-stu-id="c14d5-203">The PowerShell eventing commands are present but most of the event sources used with the commands (such as System.Timers.Timer) are not available on Linux making the commands useless in the Alpha release.</span></span>|
|`Set-ExecutionPolicy`|<span data-ttu-id="c14d5-204">可用，但不起作用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-204">Available but doesn't work.</span></span>|<span data-ttu-id="c14d5-205">返回消息，指示在此平台上不受支持。</span><span class="sxs-lookup"><span data-stu-id="c14d5-205">Returns a message saying not supported on this platform.</span></span> <span data-ttu-id="c14d5-206">执行策略是以用户为中心的“安全带”，有助于防止用户犯下代价昂贵的错误。</span><span class="sxs-lookup"><span data-stu-id="c14d5-206">Execution policy is a user-focused "safety belt" that helps prevent the user from making expensive mistakes.</span></span> <span data-ttu-id="c14d5-207">这不是安全边界。</span><span class="sxs-lookup"><span data-stu-id="c14d5-207">It is not a security boundary.</span></span>|
|<span data-ttu-id="c14d5-208">`New-PSSessionOption`, `New-PSTransportOption`</span><span class="sxs-lookup"><span data-stu-id="c14d5-208">`New-PSSessionOption`, `New-PSTransportOption`</span></span>|<span data-ttu-id="c14d5-209">可用，但 `New-PSSession` 不起作用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-209">Available but `New-PSSession` doesn't work.</span></span>|<span data-ttu-id="c14d5-210">在 `New-PSSession` 起作用时，`New-PSSessionOption` 和 `New-PSTransportOption` 当前未被验证起作用。</span><span class="sxs-lookup"><span data-stu-id="c14d5-210">`New-PSSessionOption` and `New-PSTransportOption` are not currently verified to work now that `New-PSSession` works.</span></span>|
